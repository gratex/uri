<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>_uri.js - Documentation</title>

    <script src="scripts/prettify/prettify.js"></script>
    <script src="scripts/prettify/lang-css.js"></script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc.css">
</head>
<body>

<input type="checkbox" id="nav-trigger" class="nav-trigger" />
<label for="nav-trigger" class="navicon-button x">
  <div class="navicon"></div>
</label>

<label for="nav-trigger" class="overlay"></label>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Modules</h3><ul><li><a href="module-builder.html">builder</a><ul class='methods'><li data-type='method'><a href="module-builder.html#.raw">raw</a></li><li data-type='method'><a href="module-builder.html#.uriBuilder">uriBuilder</a></li><li data-type='method'><a href="module-builder.html#.uriBuilderRql">uriBuilderRql</a></li></ul></li><li><a href="module-uri.html">uri</a><ul class='methods'><li data-type='method'><a href="module-uri.html#.checkEncoding">checkEncoding</a></li><li data-type='method'><a href="module-uri.html#.decodeSegments">decodeSegments</a></li><li data-type='method'><a href="module-uri.html#.decomposeComponents">decomposeComponents</a></li><li data-type='method'><a href="module-uri.html#.encodeSegments">encodeSegments</a></li><li data-type='method'><a href="module-uri.html#.isSubordinate">isSubordinate</a></li><li data-type='method'><a href="module-uri.html#.parseQuery">parseQuery</a></li><li data-type='method'><a href="module-uri.html#.percentEncode">percentEncode</a></li><li data-type='method'><a href="module-uri.html#.recomposeAuthorityComponents">recomposeAuthorityComponents</a></li><li data-type='method'><a href="module-uri.html#.recomposeComponents">recomposeComponents</a></li><li data-type='method'><a href="module-uri.html#.removeDotSegments">removeDotSegments</a></li><li data-type='method'><a href="module-uri.html#.resolve">resolve</a></li></ul></li><li><a href="module-Uri_.html">Uri</a><ul class='methods'><li data-type='method'><a href="module-Uri_.html#.appendFragment">appendFragment</a></li><li data-type='method'><a href="module-Uri_.html#.appendQuery">appendQuery</a></li><li data-type='method'><a href="module-Uri_.html#.appendSegments">appendSegments</a></li><li data-type='method'><a href="module-Uri_.html#.convertToFolder">convertToFolder</a></li><li data-type='method'><a href="module-Uri_.html#.denotesFolder">denotesFolder</a></li><li data-type='method'><a href="module-Uri_.html#.equals">equals</a></li><li data-type='method'><a href="module-Uri_.html#.getAuthority">getAuthority</a></li><li data-type='method'><a href="module-Uri_.html#.getFragment">getFragment</a></li><li data-type='method'><a href="module-Uri_.html#.getHost">getHost</a></li><li data-type='method'><a href="module-Uri_.html#.getLastSegment">getLastSegment</a></li><li data-type='method'><a href="module-Uri_.html#.getPath">getPath</a></li><li data-type='method'><a href="module-Uri_.html#.getPort">getPort</a></li><li data-type='method'><a href="module-Uri_.html#.getQuery">getQuery</a></li><li data-type='method'><a href="module-Uri_.html#.getScheme">getScheme</a></li><li data-type='method'><a href="module-Uri_.html#.getScreenPath">getScreenPath</a></li><li data-type='method'><a href="module-Uri_.html#.getSegments">getSegments</a></li><li data-type='method'><a href="module-Uri_.html#.getUserInfo">getUserInfo</a></li><li data-type='method'><a href="module-Uri_.html#.isSubordinate">isSubordinate</a></li><li data-type='method'><a href="module-Uri_.html#.mixin">mixin</a></li><li data-type='method'><a href="module-Uri_.html#.parseId">parseId</a></li><li data-type='method'><a href="module-Uri_.html#.resolve">resolve</a></li><li data-type='method'><a href="module-Uri_.html#.resolveAsSubordinate">resolveAsSubordinate</a></li><li data-type='method'><a href="module-Uri_.html#.resolveSvcCtx">resolveSvcCtx</a></li><li data-type='method'><a href="module-Uri_.html#.resolveUiCtx">resolveUiCtx</a></li><li data-type='method'><a href="module-Uri_.html#.setAuthority">setAuthority</a></li><li data-type='method'><a href="module-Uri_.html#.setFragment">setFragment</a></li><li data-type='method'><a href="module-Uri_.html#.setHost">setHost</a></li><li data-type='method'><a href="module-Uri_.html#.setPath">setPath</a></li><li data-type='method'><a href="module-Uri_.html#.setPort">setPort</a></li><li data-type='method'><a href="module-Uri_.html#.setQuery">setQuery</a></li><li data-type='method'><a href="module-Uri_.html#.setScheme">setScheme</a></li><li data-type='method'><a href="module-Uri_.html#.setSegments">setSegments</a></li><li data-type='method'><a href="module-Uri_.html#.setUserInfo">setUserInfo</a></li><li data-type='method'><a href="module-Uri_.html#.strip">strip</a></li><li data-type='method'><a href="module-Uri_.html#.stripCtxPath">stripCtxPath</a></li><li data-type='method'><a href="module-Uri_.html#.stripCtxPrefix">stripCtxPrefix</a></li><li data-type='method'><a href="module-Uri_.html#.stripExtension">stripExtension</a></li><li data-type='method'><a href="module-Uri_.html#.stripFragment">stripFragment</a></li><li data-type='method'><a href="module-Uri_.html#.stripOrigin">stripOrigin</a></li><li data-type='method'><a href="module-Uri_.html#.stripPath">stripPath</a></li><li data-type='method'><a href="module-Uri_.html#.stripQuery">stripQuery</a></li><li data-type='method'><a href="module-Uri_.html#.toString">toString</a></li><li data-type='method'><a href="module-Uri_.html#.toUri">toUri</a></li></ul></li></ul>
</nav>

<div id="main">
    
    <h1 class="page-title">_uri.js</h1>
    

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>/**
	 Credits to:
	 -------------------------
     1.	uri_funcs.js - URI functions based on STD 66 / RFC 3986
        Author (original): Mike J. Brown &lt;mike at skew.org>  Version: 2007-01-04
	 2.	http://jena.sourceforge.net/iri/javadoc/index.html
	 -------------------------
 **/

/**
 * @module uri
 */

/**
 * @typedef {object} UriObj
 * @property {string} scheme
 * @property {string} host
 * @property {string} port
 * @property {string} userInfo
 * @property {string} authority
 * @property {string} path
 * @property {string} query
 * @property {string} fragment
*/
const splitUriRegex = new RegExp( // IRI lib regexp
    '^' +
    '(([^:/?#]*):)?' + // scheme
    '(//((([^/?#@]*)@)?' + // user
    '(\\[[^/?#]*\\]|([^/?#:]*))?' + // host
    '(:([^/?#]*))?))?' + // port
    '([^#?]*)?' + // path
    '(\\?([^#]*))?' + // query
    '(#(.*))?' + // frag
    '$'
); //

// TODO: get rid of RFC2396 constants
const RFC2396_DIGIT = '0-9';
const RFC2396_LOWALPHA = 'a-z';
const RFC2396_UPALPHA = 'A-Z';
const RFC2396_ALPHA = RFC2396_LOWALPHA + RFC2396_UPALPHA;
const RFC2396_ALPHANUM = RFC2396_DIGIT + RFC2396_ALPHA;
const RFC3986_UNRESERVED = `${RFC2396_ALPHANUM}-._~`;
const RFC3986_SUBDELIMS = '!$&amp;\'()*+,;=';
const RFC3986_PCT_ENCODED = '';
const RFC3986_REG_NAME = `${RFC3986_UNRESERVED}${RFC3986_PCT_ENCODED}${RFC3986_SUBDELIMS}`;
const RFC3986_PCHAR = `${RFC3986_REG_NAME}:@`;
const RFC3986_QUERY = `${RFC3986_PCHAR}?/`;
const RFC3986_SEGMENT = RFC3986_PCHAR;
const RFC3986_FRAGMENT = `${RFC3986_PCHAR}?/`;
const PCHAR_TOKENIZER = /(?:%[0-9A-Fa-f]{2}){1,}|./g;
const RFC3986_PATH_SEGMENTS = `${RFC3986_SEGMENT}/`;

// must encode 'RQL query control' chars in value
// like RFC3986_QUERY, but these are not safe
//	'=>&lt;!'	FIQL syntax
//	','		arguments separator
//	':'		converter separator
//	'&amp;|'	and, or operator
//	'/'		nested property marker
//	'()'	brackets for grouping operators
// const RQL_VALUE = `${RFC3986_UNRESERVED}${RFC3986_PCT_ENCODED}@?$'*+`;
const RQL_VALUE = RFC3986_QUERY.replace(/[=>&lt;!,:&amp;|/()]/g, '');

/**
* @summary uri string to be decomposed
* @param {string} uriStr
* @memberof module:uri
* @return {UriObj}
*/

function decomposeComponents(uriStr) {
    /* eslint-disable-next-line array-bracket-spacing */ // (formatter has problems when starting with ,)
    const [,, scheme,, authority,, userInfo, host,,, port, path,, query,, fragment ] = uriStr.match(splitUriRegex);
    const u = { scheme, authority, path, query, fragment };
    if (u.authority != null) {
        Object.assign(u, { userInfo, port, host });
        // TODO: host null vs '' if authority defined but host not ?
        u.host == null &amp;&amp; (u.host = '');
    }
    u.path == null &amp;&amp; (u.path = '');
    return u;
}

/**
* @summary recomposing authority from userInfo, host and port
* @param {string} userInfo
* @param {string} host
* @param {string} port
* @memberof module:uri
* @returns {string}
*/
function recomposeAuthorityComponents(userInfo, host, port) {
    if (host == null) {
        throw new Error(`Illegal host:${host}`);
    }
    let result = '';
    result += userInfo != null ? `${userInfo}@` : '';
    result += host;
    result += port != null ? `:${port}` : '';
    return result;
}

function _checkAuthorityInvariant(authority, userInfo, host, port) {
    const b = (authority == null &amp;&amp; userInfo == null &amp;&amp; host == null &amp;&amp; port == null) ||
        (authority != null &amp;&amp; authority === recomposeAuthorityComponents(userInfo, host, port));
    if (!b) {
        throw new Error('IllegalStateException,AuthorityInvariant broken');
    }
}

/**
* @summary this will recompose uri as string from each component
* @param {UriObj} object
* @memberof module:uri
* @returns {string}
* @see 5.3.  Component Recomposition  . . . . . . . . . . . . . . . . 35
Remarks:
defined(x) is coded with !=null (means undefined and null are handled the same way)
ignores "authority sub components"
*/
function recomposeComponents({ scheme, authority, userInfo, host, port, path, query, fragment }) {
    _checkAuthorityInvariant(authority, userInfo, host, port);

    let result = '';
    result += scheme != null ? `${scheme}:` : '';
    result += authority != null ? `//${authority}` : '';
    result += path;
    result += query != null ? `?${query}` : '';
    result += fragment != null ? `#${fragment}` : '';

    return result;
}

/**
* @summary this will encode every character of string with hexadecimal ASCII code
* @param {string} str
* @param {string} legalRange regex pattern
* @memberof module:uri
* @returns {string}
*/
function percentEncode(str, legalRange) {
    const retVal = Array.from(str);
    const reLegal = legalRange &amp;&amp; new RegExp(`[${legalRange}]`);
    function encode(cp, i, buff) {
        if (reLegal &amp;&amp; cp.match(reLegal)) { return; }
        let enc = encodeURIComponent(cp);
        if (enc.length === 1) {
            enc = `%${cp.charCodeAt(0).toString(16).toUpperCase()}`;
        }
        buff[i] = enc;
    }
    retVal.forEach(encode);
    return retVal.join('');
}

/**
* @summary this will remove dot segments in path
* @param {string} path
* @memberof module:uri
* @returns {string}
*/
function removeDotSegments(path) {
    let inputBufferStart = 0;
    const inputBufferEnd = path.length;
    let output = '';
    let xi = '';
    while (inputBufferStart &lt; inputBufferEnd) {
        let _in = path.substring(inputBufferStart);
        if (_in.indexOf('./') === 0) {
            inputBufferStart += 2;
            continue;
        }
        if (_in.indexOf('../') === 0) {
            inputBufferStart += 3;
            continue;
        }
        if (_in.indexOf('/./') === 0) {
            inputBufferStart += 2;
            continue;
        }
        if (_in === '/.') {
            _in = '/';
            inputBufferStart += 2;
        // force end of loop
        }
        if (_in.indexOf('/../') === 0) {
            inputBufferStart += 3;
            xi = output.lastIndexOf('/');
            if (xi !== -1 &amp;&amp; xi !== output.length) {
                output = output.substring(0, xi);
            }
            continue;
        }
        if (_in === '/..') {
            _in = '/';
            inputBufferStart += 3;
            xi = output.lastIndexOf('/');
            if (xi !== -1 &amp;&amp; xi !== output.length) {
                output = output.substring(0, xi);
            }
        }
        if (_in === '.') {
            inputBufferStart += 1;
            continue;
        }
        if (_in === '..') {
            inputBufferStart += 2;
            continue;
        }
        let nextSlash = _in.indexOf('/', 1);
        if (nextSlash === -1) {
            nextSlash = _in.length;
        }
        inputBufferStart += nextSlash;
        output += (_in.substring(0, nextSlash));
    }
    // 5.2.4 3
    return output;
}

// 5.2.3.  Merge Paths

function _merge({ authority, path }, refPath) { // object,string
    if (authority != null &amp;&amp; path === '') {
        return `/${refPath}`;
    }
    const xi = path.lastIndexOf('/');
    return (xi === -1) ? refPath : path.substring(0, xi + 1) + refPath;
}

// 5.2.2.  Transform References

function _transformReference(base, { scheme, authority, userInfo, host, port, path, query, fragment }) {
    if (scheme == null) {
        scheme = base.scheme;
        if (authority == null) {
            ({ authority, userInfo, host, port } = base);
            if (path === '') {
                path = base.path;
                query = query != null ? query : base.query;
            } else {
                path = path.charAt(0) === '/' ? path : removeDotSegments(_merge(base, path));
            }
        }
    }
    path &amp;&amp; (path = removeDotSegments(path));
    return { scheme, authority, userInfo, host, port, path, query, fragment };
}

// 5.2.1.  Pre-parse the Base URI

function _preParseBaseUri({ scheme }) {
    if (scheme == null) {
        throw new Error('Violation 5.2.1, scheme component required');
    }
}

/**
* @summary TODO
* @param {UriObj} base
* @param {UriObj} ref
* @memberof module:uri
* @return {UriObj}
*/
function resolve(base, ref) {
    _preParseBaseUri(base);
    return _transformReference(base, ref);
}

/**
* @summary Spliting path by "/". Main reason is to eliminate unambiquity of "/a%2f%b/c" and "/a/b/c".
* @param {string} encodedPath
* @memberof module:uri
* @returns {array} Path split to DECODED segments as array
*/
function decodeSegments(encodedPath) {
    if (encodedPath === '') {
        return [];
    }
    const segments = encodedPath.split('/');
    if (segments.shift() !== '') {
        throw new Error('path-abempty expected');
    }
    return segments.map((segment) => decodeURIComponent(segment));
}

/**
* @summary Joining path segments by "/". Main reason is to eliminate unambiquity of "/a%2f%b/c" and "/a/b/c".
* @param {array} segments array of segments not encoded
* @memberof module:uri
* @returns {string} path-abempty, ENCODED path, only characters specified in RFC3986_SEGMENT are encoded if [] specified
* "" is returned
*/
function encodeSegments(segments) {
    if (!(segments instanceof Array)) {
        throw new Error('IllegalArgumentException, array of segments expected');
    }
    if (segments.length === 0) {
        return '';
    }
    return `/${segments.map((segment) => percentEncode(segment, RFC3986_SEGMENT)).join('/')}`;
}

/**
* @summary Check if path is subordinate
* @param {UriObj} uriParent
* @param {UriObj} uriSub
* @param {boolean} orSame
* @memberof module:uri
* @returns {boolean}
*/
function isSubordinate(uriParent, uriSub, orSame) {
    // if subordinate is absolute and parent is not or parent has different authority
    if (uriSub.authority != null &amp;&amp; uriSub.authority !== uriParent.authority) {
        return false;
    }
    const i = uriSub.path.indexOf(uriParent.path);
    return i === 0 &amp;&amp; (orSame || uriSub.path.length !== uriParent.path.length);
}
function encodeSegment(segment) {
    return percentEncode(segment, RFC3986_SEGMENT);
}

function encodeQuery(str) {
    return percentEncode(str, RFC3986_QUERY);
}

function encodeRqlValue(str) {
    return percentEncode(str, RQL_VALUE);
}

function encodeFragment(str) {
    return percentEncode(str, RFC3986_FRAGMENT);
}

/**
* @summary Validates if string contains legalRange + valid pchars PCHAR. PCHARS represent valid UTF-8 sequence
* @param {UriObj} raw
* @param {string} legalRange regex expression
* @param {string} doThrow
* @memberof module:uri
* @returns {error} NULL if ok, Error if failed
*/
function checkEncoding(raw, legalRange, doThrow /* , flags*/) {
    // TODO: flags: ILLEGAL_PERCENT_ENCODING, SUPERFLUOUS_ASCII_PERCENT_ENCODING
    // TODO: flags: PERCENT_ENCODING_SHOULD_BE_UPPERCASE, SUPERFLUOUS_NON_ASCII_PERCENT_ENCODING
    if (!raw) {
        return null;
    }
    const reLegal = new RegExp(`[${legalRange}]`);
    const tokens = raw.match(PCHAR_TOKENIZER);
    for (let i = 0; i &lt; tokens.length; i++) {
        const t = tokens[i];
        if (t.length > 1) {
            try {
                decodeURIComponent(t);
            } catch (ex) {
                const e = new Error(`Illegal PCHAR sequence:${t}`);
                if (doThrow) {
                    throw e;
                }
                return e;
            }
        } else if (!t.match(reLegal)) {
            const e = new Error(`Illegal PCHAR sequence:${t}`);
            if (doThrow) {
                throw e;
            }
            return e;
        }
    }
    return null;
}

function checkSegmentsEncoding(str, doThrow) {
    return checkEncoding(str, RFC3986_PATH_SEGMENTS, doThrow);
}

function checkSegmentEncoding(str, doThrow) {
    return checkEncoding(str, RFC3986_SEGMENT, doThrow);
}

function checkQueryEncoding(str, doThrow) {
    return checkEncoding(str, RFC3986_QUERY, doThrow);
}

function checkFragmentEncoding(str, doThrow) {
    return checkEncoding(str, RFC3986_FRAGMENT, doThrow);
}

/**
* @summary Striktna varianta rozoznavajuca empty a undefined query.
* @param {string} query  Ak undefined alebo null vracia null. Ak "" vracia {}, inak vracia {p1:v1,ps:[]},
*   ocakavane bez delimitera (?,#) teda z naseho API
* @param {Uri} bDecode Default false, ci dekodovat mena a values
* @memberof module:uri
* @returns {any}
*/
function parseQuery(query, bDecode) {
    // returns:	Object
    if (query == null) { return null; }
    if (query === '') { return {}; }

    return query.split('&amp;').reduce((obj, part) => {
        const [ name, val ] = part.split('=').map(bDecode ? decodeURIComponent : (p) => p);
        const currVal = obj[name];
        return {
            ...obj,
            [name]: currVal == null ? val : (Array.isArray(currVal) ? (currVal.push(val), currVal) : [ currVal, val ])
        };
    }, {});
}

module.exports = {
    checkEncoding,
    checkFragmentEncoding,
    checkQueryEncoding,
    checkSegmentEncoding,
    checkSegmentsEncoding,
    decodeSegments,
    decomposeComponents,
    encodeFragment,
    encodeQuery,
    encodeSegment,
    encodeSegments,
    encodeRqlValue,
    isSubordinate,
    parseQuery,
    percentEncode,
    recomposeAuthorityComponents,
    recomposeComponents,
    removeDotSegments,
    resolve
};
</code></pre>
        </article>
    </section>




</div>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 3.6.4</a> on Wed Jul 15 2020 15:31:42 GMT+0200 (Central European Summer Time) using the <a href="https://github.com/clenemt/docdash">docdash</a> theme.
</footer>

<script>prettyPrint();</script>
<script src="scripts/linenumber.js"></script>
</body>
</html>
